# File for testing and learning related to the canonical decomposition project.

from tetrahedron import*
from perm4 import*
from Exact_Arithmetic import*


# The Edge class has a shape, endpoints, and the tet it belongs to. 

class Edge:
	def __init__(self, edge_shape, endpoints, tet_belongs):
		self.edge_shape = edge_shape
		self.endpoints = endpoints
		self.tet_belongs = tet_belongs


# The definition of the Tetrahedron class. This will be the main class; for now I don't want a triangulation class.

# SHAPE. The shape, tet.shape, will be an element of Q(sqrt(-3)). 

# FACE GLUING. Each self.face_i_gluing is a list [tet,sigma] where tet is the tet face i is 
# glued to and sigma is a permutation of (0,1,2,3) representing the face gluing. For example, if i = 2 and
# tet0.face_i_gluing = [tet1,[0,2,1,3]], that means face 2 of tet0 is glued to face 1 of tet1 by
# vertex 0 --> vertex 0, vertex 1 --> vertex 2, vertex 3 --> vertex 3.

# SYMMETRIES. Each tetrahedron has some group of symmetries (possibly trivial) acting on it. This is not necessarily
# the full group of symmetries of the tetrahedron, just the ones which are part of the orbifold structure. Denoted tet.symmetries,
# it's a list whose elements are permutations of the four vertices, where a permutation is written as a list with elements
# 0, 1, 2, and 3. For example, if the symmetries of tet are the group generated by order 3 rotations fixing vertex 0, then
# tet.symmetries = [[0,1,2,3],[0,2,3,1],[0,3,1,2]]

"""
class Tetrahedron:
	def __init__(self, shape, index):
		self.shape = shape
		self.index = index
		self.face_0_gluing = None
		self.face_1_gluing = None
		self.face_2_gluing = None
		self.face_3_gluing = None
		self.symmetries = None
		self.edge_01 = None
		self.edge_02 = None
		self.edge_03 = None
		self.edge_12 = None
		self.edge_13 = None
		self.edge_23 = None
"""		


# The Cusp_Triangle class.

# tet_belongs is the tet that this cusp triangle belongs to, vertex_belongs is the vertex it belongs to.

# 

class Cusp_Triangle:
	def __init__(self, tet_belongs, vertex_belongs):
		self.tet_belongs = tet_belongs
		self.vertex_belongs = vertex_belongs
		self.side_0 = 1 
		self.side_1 = 1
		self.side_2 = 1

		if vertex_belongs == 0:
			self.vertex_2_edge = tet_belongs.edge_03
			self.vertex_0_edge = tet_belongs.edge_02
			self.vertex_1_edge = tet_belongs.edge_01
		if vertex_belongs == 1:
			self.vertex_2_edge = tet_belongs.edge_01
			self.vertex_0_edge = tet_belongs.edge_12
			self.vertex_1_edge = tet_belongs.edge_13
		if vertex_belong == 2:
			self.vertex_2_edge = tet_belongs.edge_02
			self.vertex_0_edge = tet_belongs.edge_23
			self.vertex_1_edge = tet_belongs.edge_12
		if vertex_belongs == 3:
			self.vertex_2_edge = tet_belongs.edge_13
			self.vertex_0_edge = tet_belongs.edge_23
			self.vertex_1_edge = tet_belongs.edge_03


	def area(self):
		s = (self.side_0+self.side_1+self.side_2)/2
		return (s*(s-self.side_0)*(s-self.side_1)*(s-self.side_2))**0.5


"""
e = Perm4((0,1,2,3))
s1 = Perm4((1,2,0,3))
b = inv(s1)*e 
s2 = Perm4((0,1,2,3))
print(e)
print(s2)
if (e[0],e[1],e[2],e[3]) == (s2[0],s2[1],s2[2],s2[3]):
	print('they are equal')
"""

L = [0,1]

while L:
	print(L)
	print(L.pop())